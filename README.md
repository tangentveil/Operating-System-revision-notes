# Operating System revision notes

The computer system can be divided into four components:

* Hardware – provides basic computing resources like CPU, memory, I/O devices.

* Operating system- Controls and coordinates use of the hardware among various applications and users.

* Application programs – These are programs that carry out a specific task other than one relating to the operation of the computer itself. For example Word processors, compilers, web browsers, database systems, video games

* Users - People, machines, other computers.


 

The operating system serves as an interface between hardware and ( Apps & Users ). It provides services for Apps & Users. It is also responsible for managing the computer system's hardware and software resources.


 ![1_1_SystemComponents](https://user-images.githubusercontent.com/59107332/179339308-1def0f46-0c01-4ca4-97d7-e6693649ffba.jpg)


Figure: A view of all components of a computer system.


 

# Operating System Services

The OS provides services that are helpful to the user are

* User interface (CUI/shell and GUI):   Users can issue commands to the computer system using a command-line interface(CLI), a Graphical User Interface(GUI ), or a batch command system.

* Program execution: The OS should be able to load a program into the main memory(RAM), run and terminate the program, either normally or abnormally.

* I/O operation: The Operating System is responsible for the transfer of data to and from I/O devices(keyboards, terminals, printers, and storage devices).

* File system manipulation:  - The Operating System also maintains directory and subdirectory structures.

* Communication:  The OS also provides means for Inter-process communications(IPC) between processes.

* Error detection:  Both hardware and software errors must be detected and handled appropriately, with minimal harmful repercussions. 


 

OS services that are helpful to the system-

* Resource allocation: When multiple users or multiple jobs are running simultaneously, resources need to be allocated to each of them. The operating system manages many different types of resources.

* Accounting: The OS helps keep track of system activity and resource usage.

* Protection and Security: The OS help prevents harm to the system and resources. The harm can come through wayward internal processes or malicious outsiders. Authentication, ownership, and restricted access are prominent parts of this sy



 

# Kernel and Shell
The kernel is that part of the operating system responsible for interacting with the hardware directly.

A shell, also referred to as a command interpreter, is that part of the operating system that receives commands from the users.

 

# System Calls
 

A system call provides means for an application program to request a service from the kernel for which it does not have permission. 

Application programs usually do not have permission to perform operations like accessing I/O devices and communicating with other programs. System calls are generally written in C or C++, although some are written in assembly for optimal performance.
 

System calls are of six major categories as given in the following figure.


 ![2_08_SystemCallTypes](https://user-images.githubusercontent.com/59107332/179339624-f37d5f9e-85c2-4d32-af3d-d3d449818f98.jpg)


 

# Some more details (extras):
 
SIGHUP ("signal hang up") is a signal sent to a process when its controlling terminal is closed. (It was originally designed to notify the process of a serial line drop.)HUP signals are sometimes generated by the terminal driver in an attempt to “clean up” (i.e., kill) the processes attached to a particular terminal.

The SIGTERM signal is also called a standard kill. Whenever kill is executed without specifying the signal, a kill -15 is assumed.

The SIGKILL is different from most other signals in that it is not being sent to the process, but to the Linux kernel. A kill -9 is also called a sure kill. The kernel will shoot down the process.

A running process can be suspended when it receives a SIGSTOP signal. This is the same as kill -19 on Linux.

A suspended process does not use any cpu cycles, but it stays in memory and can be reanimated with a SIGCONT signal (kill -18 on Linux).

Some processes can be suspended with the Ctrl-Z key combination. This sends a SIGSTOP signal to the Linux kernel, effectively freezing the operation of the process. When doing this in vi(m), then vi(m) goes to the background. The background vi(m) can be seen with the jobs command.

Running the fg command will bring a background job to the foreground. The number of the background job to bring forward is the parameter of fg.

Jobs that are suspended in background can be started in background with bg. The bg will send a SIGCONT signal.

That will suspend execution of the process. It won't immediately free the memory used by it, but as memory is required for other processes the memory used by the stopped process will be gradually swapped out.


 

**SIGNAL INTERNALS**

A signal is generated either by the kernel internally (for example, SIGSEGV when an invalid address is accessed, or SIGQUIT when you hit Ctrl+\), or by a program using the kill syscall (or several related ones).

The CPU, based on a special register value, has an address in memory where it expects to find an "interrupt descriptor table" which is actually a vector table. There is one vector for every possible exception, like division by zero, or trap, like INT 3 (debug). When the CPU encounters the exception it saves the flags and the current instruction pointer on the stack and then jumps to the address specified by the relevant vector. In Linux this vector always points into the kernel, where there is an exception handler. The CPU is now done, and the Linux kernel takes over.

 Note, that you can also trigger an exception from software. For example, the user presses CTRL-C, then this call goes to the kernel which calls its own exception handler. In general, there are different ways to get to the handler, but regardless the same basic thing happens: the context gets saved on the stack and the kernel's exception handler is jumped to.

The exception handler then decides what thread should receive the signal

To send the signal what the kernel does is first set a value indicating the type of signal, SIGHUP  or whatever. This is just an integer. Every process has a "pending signal" memory area where this value is stored. Then the kernel creates a data structure with the signal information. This structure includes a signal "disposition" which may be default, ignore or handle. The kernel then calls its own function do_signal() . The next phase begins.

do_signal()first decides whether itwill handle the signal. For example, if it is a kill , then do_signal()just kills the process, end of story. Otherwise, it looks at the disposition. If the disposition is default, then do_signal()handles the signal according to a default policy that depends on the signal. If the disposition is handle, then it means there is a function in the user program which is designed to handle the signal in question and the pointer to this function will be in the aforementioned data structure. In this case do_signal() calls another kernel function, handle_signal() , which then goes through the process of switching back to user mode and calling this function. The details of this handoff are extremely complex. This code in your program is usually linked automatically into your program when you use the functions in signal.h
 

# Interrupt
An interrupt is a signal triggered by hardware or software when an event or a process needs urgent attention. The interrupt requires interruption of the current working process for a higher priority process.
 

# Dual Operation Mode
To ensure the proper functioning of the OS, we should be able to distinguish between the execution of operating-system code and user program code. Two separate modes of operation called user mode and kernel mode are used. The system is in user mode when executing harmless code in user applications. The system is in kernel mode (also known as system mode, supervisor mode, privileged mode) when executing potentially dangerous code in the system kernel.

Certain privileged instructions can only be executed in kernel mode. Kernel-mode can be entered by making system calls. A bit, called the mode bit is added to the hardware of the computer to indicate the current mode: kernel (0) or user (1).  No user code can flip the mode bit.


![1_10_UserToKernelMode](https://user-images.githubusercontent.com/59107332/179339647-024795e0-15c4-43e6-b898-9eeb63f30279.jpg)

Figure: User mode and Kernel-mode transition
 

# Booting
Booting is the process of starting the computer and loading the kernel. When a computer is turned on, the power-on-self-test (POST) is performed. Then the bootstrap loader, which resides in the ROM, is executed. The bootstrap loader loads the kernel or a more sophisticated loader.

 
# Types of operating systems 
Batch-processing Operating System: It takes jobs with similar requirements and groups them into batches. It is the responsibility of the operator to sort jobs with similar needs. 

Single-processing Operating System: It executes a single process at a given time. 

Multi-programming Operating System: It increases CPU utilization as it keeps multiple jobs in the memory so that the CPU always has one job to execute.

Multi-tasking Operating System: It is an extension of multiprogramming where the CPU executes multiple tasks by switching among them.
